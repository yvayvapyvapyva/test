<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Route Navigator Gist Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=YANDEX_API_KEY&lang=ru_RU&suppressMapOpenBlock=true"></script>
    <style>
        :root { 
            --bg: var(--tg-theme-bg-color, #f5f5f7); 
            --btn: var(--tg-theme-button-color, #007AFF); 
            --btn-txt: var(--tg-theme-button-text-color, #fff);
            --sheet-bg: rgba(255, 255, 255, 0.95);
            --text-main: #1d1d1f;
            --text-sub: #86868b;
            --accent: #007AFF;
            --card-bg: #ffffff;
            --border: rgba(0,0,0,0.1);
        }
        
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; background: #000; 
            position: fixed; touch-action: none;
        }

        #map { position: absolute; inset: 0; z-index: 1; touch-action: auto; }
        [class*="-copyrights-pane"], [class*="-map-copyrights-promo"], [class*="-controls-pane"] { display: none !important; }

        /* Navigation HUD top left */
        #navHud {
            position: absolute; top: 16px; left: 16px; right: 110px;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border-radius: 20px; padding: 16px; color: white; z-index: 9000;
            display: none; flex-direction: column; gap: 8px; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        #navHud.active { display: flex; }
        
        .hud-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; }
        .hud-cmd { font-size: 17px; font-weight: 700; color: #fff; line-height: 1.2; flex: 1; }
        .hud-next-label { font-size: 10px; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
        
        .hud-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 4px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; }
        .stat-item { display: flex; flex-direction: column; }
        .stat-label { font-size: 9px; color: #aaa; text-transform: uppercase; }
        .stat-value { font-size: 14px; font-weight: 600; font-variant-numeric: tabular-nums; color: #fff; }
        .highlight { color: #34C759; }

        /* Telemetry top right */
        #telemetryHud {
            position: absolute; top: 16px; right: 16px;
            z-index: 9001;
            background: rgba(0,0,0,0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 16px; padding: 10px; color: white;
            display: flex; flex-direction: column; gap: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 70px; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .tel-item { display: flex; flex-direction: column; align-items: center; }
        .tel-label { font-size: 8px; color: #aaa; text-transform: uppercase; line-height: 1; margin-bottom: 2px; }
        .tel-value { font-size: 14px; font-weight: 800; font-variant-numeric: tabular-nums; }

        .filter-container { 
            position: absolute; bottom: 40px; right: 16px; left: 16px; 
            z-index: 9000; display: flex; flex-direction: column-reverse; 
            align-items: flex-end; gap: 12px; 
            pointer-events: none;
        }
        .map-btn { 
            pointer-events: auto;
            width: 56px; height: 56px; border-radius: 50%; 
            background: rgba(0,0,0,.75); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); 
            border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 8px 32px rgba(0,0,0,0.3); 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            transition: all 0.2s ease; 
        }
        .map-btn svg { fill: white; width: 26px; pointer-events: none; }
        .map-btn.active { background: var(--btn); }

        #filterMenu { 
            pointer-events: auto;
            background: var(--sheet-bg); 
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); 
            border-radius: 24px; box-shadow: 0 20px 40px rgba(0,0,0,0.2); 
            display: none; flex-direction: column; 
            border: 1px solid rgba(255,255,255,0.4); margin-bottom: 12px; 
            min-width: 260px;
            max-width: calc(100vw - 32px); 
            max-height: 75vh; overflow: hidden;
            align-self: flex-end;
        }
        #filterMenu.active { display: flex; }

        .menu-header { padding: 16px 16px 8px 16px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
        .menu-title { font-size: 11px; font-weight: 800; color: var(--text-sub); text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 8px; }

        #pointsList { 
            overflow-y: auto; flex: 1; padding: 8px;
            display: flex; flex-direction: column; gap: 6px;
            background: rgba(0,0,0,0.01);
            -webkit-overflow-scrolling: touch;
        }
        .point-item {
            display: flex; align-items: flex-start; gap: 12px; padding: 12px;
            border-radius: 16px; background: #fff; cursor: pointer;
            border: 1px solid transparent; transition: background 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.02);
        }
        .point-item:active { background: #f2f2f7; }
        .point-item.active { border-color: var(--accent); background: rgba(0,122,255,0.05); }
        .point-item.passed { opacity: 0.45; filter: grayscale(0.5); }
        
        .point-badge { 
            min-width: 24px; width: 24px; height: 24px; border-radius: 50%; 
            background: #f0f0f2; color: var(--text-main); 
            font-size: 11px; font-weight: 800; 
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; margin-top: 1px;
        }
        .active .point-badge { background: var(--accent); color: #fff; }
        .point-name { font-size: 14px; font-weight: 600; color: var(--text-main); line-height: 1.3; word-break: break-word; }

        .settings-area { padding: 12px; background: #fff; border-top: 1px solid var(--border); flex-shrink: 0; display: flex; flex-direction: column; gap: 10px; }
        .input-group { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        .input-label { font-size: 12px; font-weight: 600; color: var(--text-main); }
        .trigger-input { 
            width: 60px; padding: 8px; border-radius: 8px; border: 1px solid var(--border); 
            background: #f9f9f9; text-align: center; font-size: 13px; font-weight: 700;
        }

        .source-select { 
            width: 100%; padding: 10px; border-radius: 12px; border: 1px solid var(--border); 
            background: #f9f9f9; font-size: 13px; font-weight: 600; appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 10px center; background-size: 14px;
        }

        .loading-overlay { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; }
        .loading-overlay.hidden { display: none; }

        #noSleepVideo { position: absolute; width: 1px; height: 1px; opacity: 0.01; pointer-events: none; }
    </style>
</head>
<body>

<div id="loading" class="loading-overlay">Загрузка данных...</div>
<div id="map"></div>

<video id="noSleepVideo" playsinline loop muted></video>

<div id="telemetryHud">
    <div class="tel-item">
        <span class="tel-label">КМ/Ч</span>
        <span class="tel-value" id="telSpeed">0</span>
    </div>
    <div style="height:1px; width:80%; background:rgba(255,255,255,0.1); margin:2px 0;"></div>
    <div class="tel-item">
        <span class="tel-label">АЗИМУТ</span>
        <span class="tel-value" id="telAz">0°</span>
    </div>
</div>

<div id="navHud">
    <div class="hud-next-label">Следующая цель:</div>
    <div class="hud-row">
        <div class="hud-cmd" id="hudCmd">Ожидание...</div>
    </div>
    <div class="hud-stats">
        <div class="stat-item">
            <span class="stat-label">Дистанция</span>
            <span class="stat-value highlight" id="hudDist">---</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Цель азимут</span>
            <span class="stat-value" id="hudTargetAz">---</span>
        </div>
    </div>
</div>

<div class="filter-container">
    <div class="map-btn" onclick="toggleMenu(); handleUserInteraction();"><svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/></svg></div>
    
    <div id="filterMenu">
        <div class="menu-header">
            <div class="menu-title">Маршрут</div>
        </div>
        <div id="pointsList"></div>
        <div class="settings-area">
            <div class="input-group">
                <span class="input-label">Триггер (метры)</span>
                <input type="number" id="triggerInput" class="trigger-input" value="25" min="5" max="500" onchange="updateTrigger(this.value)">
            </div>
            <div>
                <div class="menu-title" style="margin-bottom:4px; font-size:10px;">Файл маршрута</div>
                <select id="sourceSelect" class="source-select" onchange="loadData(this.value); toggleMenu(false); handleUserInteraction();">
                    <option value="" disabled selected>Загрузка...</option>
                </select>
            </div>
        </div>
    </div>

    <div id="locateBtn" class="map-btn" onclick="toggleAutoCenter(); handleUserInteraction();"><svg viewBox="0 0 24 24"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg></div>
</div>

<script>
const tg = window.Telegram.WebApp;
const CFG = {
    USER_ID: "yvayvapyvapyva",
    TRIGGER_DIST: 25,
    COLORS: { Gold: '#FFD700', Blue: '#007AFF', Red: '#FF3B30', Lime: '#34C759', Fuchsia: '#AF52DE', Orange: '#FF9500', Purple: '#5856D6', Cyan: '#5AC8FA', Brown: '#A2845E', Grey: '#8E8E93' }
};

let map, objectManager, userMarker, pathsCollection;
let pointsData = [], gistSources = [];
let currentIndex = -1, autoCenter = false, iconCache = new Map();
let lastUserCoords = null, lastUserSpeed = 0, lastUserAz = 0;
let wakeLock = null;
let ttsEnabled = false;

tg.ready();
tg.expand();

const ui = id => document.getElementById(id);

// Разблокировка TTS и WakeLock по клику
async function handleUserInteraction() {
    applyWakeLock();
    if (!ttsEnabled) {
        // Проигрываем пустую фразу для разблокировки аудио-движка
        const silence = new SpeechSynthesisUtterance("");
        window.speechSynthesis.speak(silence);
        ttsEnabled = true;
        console.log("TTS Engine Unlocked");
    }
}

async function applyWakeLock() {
    const video = ui('noSleepVideo');
    if (video.paused) {
        if (!video.src) {
            video.src = 'data:video/mp4;base64,AAAAHGZ0eXBpc29tAAAAAGlzb21tcDQyAAAACHZyZWQAAAAId2lkdGgAAAAIaGVpZ2h0AAAACmRhdGEAAAAAAA==';
        }
        video.play().catch(e => console.log("Video Play Blocked"));
    }

    if ('wakeLock' in navigator) {
        try {
            if (wakeLock) await wakeLock.release();
            wakeLock = await navigator.wakeLock.request('screen');
        } catch (err) {
            console.warn(`Wake Lock Error: ${err.name}`);
        }
    }
}

document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') applyWakeLock();
});

// Глобальные слушатели для гарантированной активации на мобильных
document.addEventListener('click', handleUserInteraction, { once: false });
document.addEventListener('touchstart', handleUserInteraction, { once: false });

ymaps.ready(async () => {
    map = new ymaps.Map("map", { 
        center: [55.75, 37.62], 
        zoom: 11, 
        type: 'yandex#satellite', 
        controls: [] 
    });
    
    objectManager = new ymaps.GeoObjectCollection();
    pathsCollection = new ymaps.GeoObjectCollection();
    
    map.geoObjects.add(objectManager);
    map.geoObjects.add(pathsCollection);

    initUserTracking();
    await fetchGistSources();
    if (gistSources.length > 0) loadData(gistSources[0].url);
    
    applyWakeLock();
});

function updateTrigger(val) {
    CFG.TRIGGER_DIST = parseInt(val) || 25;
}

async function fetchGistSources() {
    try {
        const res = await fetch(`https://api.github.com/users/${CFG.USER_ID}/gists`);
        const gists = await res.json();
        gistSources = [];
        gists.forEach(g => {
            Object.values(g.files).forEach(f => {
                if (f.filename.endsWith('.json')) {
                    gistSources.push({ name: f.filename.replace('.json',''), url: f.raw_url });
                }
            });
        });
        updateFileSelector();
    } catch (e) { ui('loading').innerText = "Ошибка GitHub"; }
}

function updateFileSelector() {
    const select = ui('sourceSelect');
    select.innerHTML = gistSources.map(s => `<option value="${s.url}">${s.name}</option>`).join('');
}

async function loadData(url) {
    ui('loading').classList.remove('hidden');
    iconCache.clear();
    objectManager.removeAll();
    pathsCollection.removeAll();
    currentIndex = -1;
    ui('navHud').classList.remove('active');

    try {
        const res = await fetch(url);
        const data = await res.json();
        pointsData = data.map(d => ({
            ...d, 
            hex: CFG.COLORS[d.color] || d.color || '#007AFF',
            command: d.paths?.[0]?.cmd?.[0] || d.comment || "Точка " + d.id,
            fixedAz: d.az || 0
        }));

        currentIndex = 0;
        updateVisibleMarkers();

        const bounds = objectManager.getBounds();
        if (bounds) map.setBounds(bounds, { zoomMargin: 60 });
        
        renderPointsList();
        drawActivePath();
        
        ui('navHud').classList.add('active');
        updateHUD();

        ui('loading').classList.add('hidden');
    } catch (e) { ui('loading').innerText = "Ошибка загрузки"; }
}

function updateVisibleMarkers() {
    objectManager.removeAll();
    pointsData.forEach((p, i) => {
        if (i >= currentIndex) {
            const isTarget = i === currentIndex;
            const hasComm = p.paths?.some(path => path.comm);
            
            const placemark = new ymaps.Placemark([p.lat, p.lon], {}, {
                iconLayout: 'default#imageWithContent',
                iconImageHref: getIcon(p.hex, `${p.id}${hasComm?'!':''}`, p.fixedAz, false, isTarget ? 1.0 : 0.5),
                iconImageSize: [40, 40],
                iconImageOffset: [-20, -20],
                hasBalloon: false,
                hasHint: false
            });
            
            objectManager.add(placemark);
        }
    });
}

function getIconHtml(col, txt, az, isEnd, opacity = 1.0) {
    const isRed = txt.includes('!');
    const s = isEnd ? 34 : 40, c = s/2, t = txt.replace('!', '');
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" style="opacity: ${opacity}"><g transform="rotate(${az},${c},${c})"><polygon points="${c},2 ${c+10},${s-5} ${c},${s-14} ${c-10},${s-5}" fill="${col}" stroke="${isEnd?'white':'black'}" stroke-width="1.5"/></g><circle cx="${c}" cy="${c}" r="${isEnd?7:9}" fill="${col}" stroke="${isEnd?'white':'black'}" stroke-width="1"/><text x="${c}" y="${c+0.5}" font-size="9" font-family="Arial" font-weight="900" text-anchor="middle" dominant-baseline="middle" fill="${isRed?'#FF3B30':'#000'}" stroke="white" stroke-width="2" style="paint-order:stroke fill">${t}</text></svg>`;
}

function getIcon(col, txt, az, isEnd, opacity = 1.0) {
    const key = `${col}-${txt}-${az}-${isEnd}-${opacity}`;
    if (iconCache.has(key)) return iconCache.get(key);
    const svg = getIconHtml(col, txt, az, isEnd, opacity);
    const res = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
    iconCache.set(key, res);
    return res;
}

function getUserIcon(az) {
    const s = 32, c = s/2;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}"><g transform="rotate(${az},${c},${c})"><path d="M${c},2 L${s-4},${s-2} L${c},${s-8} L4,${s-2} Z" fill="#FF3B30" stroke="white" stroke-width="2" stroke-linejoin="round"/></g></svg>`;
    return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
}

function calculateAzimuth(p1, p2) {
    const lat1 = p1[0] * Math.PI / 180, lon1 = p1[1] * Math.PI / 180;
    const lat2 = p2[0] * Math.PI / 180, lon2 = p2[1] * Math.PI / 180;
    const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
}

function isAngleWithin(angle1, angle2, tolerance) {
    let diff = Math.abs(angle1 - angle2) % 360;
    if (diff > 180) diff = 360 - diff;
    return diff <= tolerance;
}

function initUserTracking() {
    userMarker = new ymaps.Placemark([0,0], {}, {
        iconLayout: 'default#image', 
        iconImageSize: [32, 32], 
        iconImageOffset: [-16, -16],
        iconImageHref: getUserIcon(0)
    });
    map.geoObjects.add(userMarker);

    if (navigator.geolocation) {
        navigator.geolocation.watchPosition(pos => {
            const coords = [pos.coords.latitude, pos.coords.longitude];
            const speed = pos.coords.speed ? pos.coords.speed * 3.6 : 0;
            
            let userAz = 0;
            if (pos.coords.heading !== null && pos.coords.heading !== undefined) {
                userAz = pos.coords.heading;
            } else if (lastUserCoords) {
                userAz = calculateAzimuth(lastUserCoords, coords);
            }
            
            lastUserCoords = coords;
            lastUserSpeed = speed;
            lastUserAz = userAz;

            userMarker.geometry.setCoordinates(coords);
            userMarker.options.set('iconImageHref', getUserIcon(userAz));
            
            ui('telSpeed').innerText = Math.round(speed);
            ui('telAz').innerText = `${Math.round(userAz)}°`;
            
            if (autoCenter) map.panTo(coords);
            
            checkNavigation();
        }, null, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
    }
}

function updateHUD() {
    if (pointsData.length === 0 || currentIndex === -1) return;
    
    if (currentIndex >= pointsData.length) {
        ui('hudCmd').innerText = "Маршрут завершен";
        ui('hudDist').innerText = "---";
        return;
    }

    const target = pointsData[currentIndex];
    ui('hudCmd').innerText = target.command;
    ui('hudTargetAz').innerText = `${Math.round(target.fixedAz)}°`;

    if (lastUserCoords) {
        const dist = ymaps.coordSystem.geo.getDistance(lastUserCoords, [target.lat, target.lon]);
        ui('hudDist').innerText = `${Math.round(dist)} м`;
    }
}

function checkNavigation() {
    if (pointsData.length === 0 || currentIndex === -1 || !lastUserCoords) return;
    if (currentIndex >= pointsData.length) return;

    const target = pointsData[currentIndex];
    const dist = ymaps.coordSystem.geo.getDistance(lastUserCoords, [target.lat, target.lon]);
    const bearingToTarget = calculateAzimuth(lastUserCoords, [target.lat, target.lon]);

    updateHUD();

    const withinDistance = dist <= CFG.TRIGGER_DIST;
    const isHeadingCorrect = isAngleWithin(lastUserAz, bearingToTarget, 45);

    if (withinDistance && isHeadingCorrect) {
        console.log(`Trigger! Point: ${target.id}, Cmd: ${target.command}`);
        announce(target.command);
        currentIndex++;
        
        updateVisibleMarkers();
        if (currentIndex < pointsData.length) {
            drawActivePath();
            renderPointsList();
            updateHUD();
        } else {
            pathsCollection.removeAll();
            ui('hudCmd').innerText = "Маршрут завершен";
            ui('hudDist').innerText = "---";
        }
    }
}

function renderPointsList() {
    const list = ui('pointsList');
    list.innerHTML = pointsData.map((p, i) => `
        <div id="point-${i}" class="point-item ${i === currentIndex ? 'active' : ''} ${i < currentIndex ? 'passed' : ''}" onclick="jumpTo(${i}); handleUserInteraction();">
            <div class="point-badge">${i + 1}</div>
            <div class="point-name">${p.command}</div>
        </div>
    `).join('');
    if (currentIndex >= 0) {
        const activeEl = ui(`point-${currentIndex}`);
        if (activeEl) activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function jumpTo(idx) {
    currentIndex = idx;
    updateVisibleMarkers();
    const target = pointsData[idx];
    if (target) {
        map.panTo([target.lat, target.lon], { zoom: 17 });
        drawActivePath();
        renderPointsList();
        ui('navHud').classList.add('active');
        updateHUD();
        toggleMenu(false);
    }
}

function drawActivePath() {
    pathsCollection.removeAll();
    if (currentIndex >= pointsData.length) return;
    
    const target = pointsData[currentIndex];
    if (target?.paths) {
        target.paths.forEach(p => {
            if (p.pts?.length > 0) {
                pathsCollection.add(new ymaps.Polyline(p.pts, {}, { 
                    strokeColor: target.hex, 
                    strokeWidth: 5, 
                    strokeOpacity: 0.8 
                }));
                
                const lastIdx = p.pts.length - 1;
                const lastPt = p.pts[lastIdx];
                let arrowAz = target.fixedAz;
                if (p.pts.length >= 2) arrowAz = calculateAzimuth(p.pts[lastIdx - 1], lastPt);
                
                pathsCollection.add(new ymaps.Placemark(lastPt, {}, {
                    iconLayout: 'default#imageWithContent', 
                    iconImageSize: [34, 34], 
                    iconImageOffset: [-17, -17],
                    iconImageHref: getIcon(target.hex, String(target.id), arrowAz, true)
                }));
            }
        });
    }
}

function announce(text) {
    if (!text || !window.speechSynthesis) return;
    
    console.log("Attempting to speak:", text);
    
    // Останавливаем текущую речь
    window.speechSynthesis.cancel();
    
    const msg = new SpeechSynthesisUtterance(text);
    msg.lang = 'ru-RU';
    msg.volume = 1.0;
    msg.rate = 1.0;
    msg.pitch = 1.0;

    // Важно для мобильных: если движок "завис", переинициализируем
    msg.onend = () => console.log("Speech finished");
    msg.onerror = (e) => console.error("Speech error:", e);
    
    window.speechSynthesis.speak(msg);
}

function toggleMenu(val) {
    const menu = ui('filterMenu');
    menu.style.display = (val ?? menu.style.display !== 'flex') ? 'flex' : 'none';
}

function toggleAutoCenter() { 
    autoCenter = !autoCenter; 
    ui('locateBtn').classList.toggle('active', autoCenter); 
}
</script>
</body>
</html>
